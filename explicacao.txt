Vou deixar uma explicação rápida do que estava acontecendo.

[Problema]

O primeiro erro é que estavamos tentando escrever/ler nos sockets
muito rápido. Quando tentamos fazer um send() e/ou um recv() em um
socket mas o socket não está pronto para escrita/leitura, recebemos um
erro.

[Solução]

Mudando o código de lugar e usando selector.EVENT_WRITE para saber
quando o socket está pronto para escrita podemos evitar o problema.

################################################################################

[Problema]

O nosso laço de loop do select é muito rápido. Ele é executado várias
vezes antes de uma mensagem chegar para o cliente/servidor.

Vamos imaginar que nosso arquivo é o seguinte:

[myfile.txt]
Hello World

Quando lemos o arquivo do lado de quem vai enviar, vamos calcular o
tamanho do arquivo e mandar uma mensagem com o tamanho do arquivo (ou
com o número de partes) e uma segunda mensagem com o conteúdo do
arquivo. Por exemplo:

# Mensagem indicando que o arquivo tem 11 bytes
11

# Mensagem com o conteúdo
Hello World

O problema é que as mensagens chegam 'ao mesmo tempo' do outro lado e
quando fazemos o recv(), vamos receber somente uma mensagem:

# Mensagem recebida
11Hello World

[Solução]

Usar demarcadores para saber onde uma mensagem começa e onde ela
termina. No caso eu escolhi o marcador 'FIL' para indicar o começo de
uma mensagem. Usando o marcador as mensagens seriam:

FIL11
FILHello World

Mesmo que elas cheguem juntas, teremos:

FIL11FILHello World

Então é possível separar a mensagem em pedaços.

################################################################################

[Problema]

Se o usuário usar o marcador dentro do arquivo, vamos ter problemas.

[Solução]

Temos que encontrar outra maneira de limitar as mensagens, tavlez
mandando o tamanho de cada mensagem depois do 'FIL'.

>>> Este último problema não foi resolvido no código que coloquei para
    vocês.

O ideal seria 'FIL' (ou outro marcador) seguido de dois bytes que
indiquem o tamanho do próximo campo ... ou algo do tipo.
